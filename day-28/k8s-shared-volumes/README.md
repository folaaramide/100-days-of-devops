# Day 28 - Sharing Volumes Between Containers in Kubernetes
As part of my 100 Days of DevOps Challenge, todayâ€™s focus was on Kubernetes pod volumes â€” specifically, how multiple containers within a single pod can share data using an emptyDir volume.

This lab builds on my earlier Kubernetes learnings (Pods, Deployments, ConfigMaps, Secrets) and moves deeper into state handling inside clusters.

## Business Need
Modern applications often run in multi-container pods where containers need to exchange data at runtime. For example:

â€¢	A logging sidecar collecting app logs written by the main app container.

â€¢	A data pre-processor feeding real-time files to a consumer container.

â€¢	A CI/CD pipeline step where build artifacts are generated by one container and consumed by another.

Kubernetesâ€™ emptyDir volumes provide a temporary, high-performance storage solution for such cases. This allows containers in the same pod to work together seamlessly without needing external persistent storage.
## Business Value:
â€¢	Faster data exchange between services.

â€¢	Cost savings by reducing dependency on external storage (S3, NFS, etc.) when only ephemeral data is needed.

â€¢	Improved performance as data is stored locally on the podâ€™s node.

## Task Breakdown
1.	Create a pod with two containers (debian:latest).

-Container 1 mounts /tmp/news.

-Container 2 mounts /tmp/cluster.

-Both share the same emptyDir volume.

2.	Write a file (news.txt) from container 1.
3.	Verify file availability in container 2.
4.	Confirm shared volume works with correct permissions.

## Kubernetes YAML
Hereâ€™s the manifest I applied:
apiVersion: v1
kind: Pod
metadata:
  name: volume-share-nautilus
spec:
  containers:
    - name: volume-container-nautilus-1
      image: debian:latest
      command: ["sh", "-c", "sleep 3600"]
      volumeMounts:
        - name: volume-share
          mountPath: /tmp/news
    - name: volume-container-nautilus-2
      image: debian:latest
      command: ["sh", "-c", "sleep 3600"]
      volumeMounts:
        - name: volume-share
          mountPath: /tmp/cluster
  volumes:
    - name: volume-share
      emptyDir: {}
ðŸ“¸ Suggested screenshot (save as day26_pod_yaml.png)
â€¢	Take a screenshot of your volume-share-nautilus.yaml file.

## Execution & Verification

1.	Pod Creation

kubectl apply -f volume-share-nautilus.yaml

kubectl get pods -o wide

â€¢	Verified that the pod is running with 2 containers.

ðŸ“¸ Screenshot: day26_pod_running.png
(output of kubectl get pods -o wide)

2.	Write File in Container 1

kubectl exec -it volume-share-nautilus -c volume-container-nautilus-1 -- sh

echo "Hello from container 1 at $(date)" > /tmp/news/news.txt

ls -l /tmp/news
ðŸ“¸ Screenshot: day26_container1_file.png
(showing file created inside /tmp/news/)

3.	Verify in Container 2

kubectl exec -it volume-share-nautilus -c volume-container-nautilus-2 -- sh

ls -l /tmp/cluster

cat /tmp/cluster/news.txt

ðŸ“¸ Screenshot: day26_container2_file.png
(showing same file accessible in /tmp/cluster/)

## Key Learnings

â€¢	emptyDir volumes are tied to the lifecycle of a pod â†’ data is deleted when the pod is removed.

â€¢	Useful for temporary storage, caching, and inter-container communication.

â€¢	Reinforces real-world patterns like sidecar logging and multi-stage pipelines.

## Benefits of This Task
â€¢	Demonstrates how cloud-native workloads handle intra-pod communication.

â€¢	Shows efficiency in DevOps pipelines where containers share artifacts.

â€¢	Aligns with enterprise needs for scalable, cost-effective data handling in Kubernetes.
